"""
Show the gradient flow generated by the trained MLP as a vector field.

Usage:
  python -m ncsnv2.visualization.viz_mlp_gradient_flow --config uniform_2d.yml \
      --doc <run> --ckpt-id 20000 --n 32 --out mlp_gradient_flow.png
"""

import argparse
import sys
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import torch
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

PROJECT_ROOT = Path(__file__).resolve().parent.parent
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

from visualization.viz_mlp_norm_2d import (
    build_model,
    load_config,
    load_state_dict,
    resolve_checkpoint,
    resolve_config_path,
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="3D vector flow for MLP2D outputs.")
    parser.add_argument("--config", default="student_mixture_2d.yml", help="Config file name or path.")
    parser.add_argument("--exp", default="experiments", help="Experiment root.")
    parser.add_argument("--doc", default=None, help="Run name under logs/. Defaults to config stem.")
    parser.add_argument("--ckpt-id", type=int, default=None, help="Checkpoint suffix after checkpoint_.")
    parser.add_argument("--ckpt", default=None, help="Direct path to a checkpoint.")
    parser.add_argument("--n", type=int, default=20, help="Grid size per axis (controls number of arrows).")
    parser.add_argument("--device", default=None, help="Device for model and inference (cpu|cuda). Auto-detect if None.")
    parser.add_argument("--out", default="figures/mlp_gradient_flow.png", help="Output image path.")
    parser.add_argument("--sigma-idx", type=int, default=0, help="Noise level index (0 = highest noise).")
    return parser.parse_args()


def main():
    args = parse_args()

    if args.device is None:
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    else:
        device = torch.device(args.device)

    cfg_path = resolve_config_path(args.config)
    cfg = load_config(cfg_path)
    # ensure config carries a torch.device for functions that expect it
    cfg.device = device
    ckpt_path = resolve_checkpoint(args, cfg)
    state_dict = load_state_dict(ckpt_path)

    model = build_model(cfg).to(device)
    model.load_state_dict(state_dict, strict=False)
    
    # Gérer EMA si présent
    states = torch.load(ckpt_path, map_location='cpu', weights_only=False)
    if cfg.model.ema and len(states) > 4:
        from models.ema import EMAHelper
        ema = EMAHelper(mu=cfg.model.ema_rate)
        ema.register(model)
        ema.load_state_dict(states[-1])
        ema.ema(model)
    
    model.eval()

    # Limites fixes pour student_mixture_2d
    minx, maxx = -10.0, 20.0
    miny, maxy = -10.0, 20.0

    xs = torch.linspace(minx, maxx, args.n)
    ys = torch.linspace(miny, maxy, args.n)
    X, Y = torch.meshgrid(xs, ys, indexing="ij")
    pts = torch.stack([X.reshape(-1), Y.reshape(-1)], dim=1).to(device)

    with torch.no_grad():
        # Noise level index
        labels = torch.full((pts.shape[0],), args.sigma_idx, dtype=torch.long, device=device)
        outputs = model(pts, labels)

    outputs = outputs if outputs.ndim > 1 else outputs[:, None]
    U = outputs[:, 0].cpu().numpy().reshape(args.n, args.n)
    V = outputs[:, 1].cpu().numpy().reshape(args.n, args.n)

    magnitudes = np.hypot(U, V)
    Z = np.zeros_like(U)
    W = np.zeros_like(U)

    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection="3d")
    norm = plt.Normalize(vmin=magnitudes.min(), vmax=magnitudes.max())
    # flatten arrays for quiver
    Xf, Yf = X.numpy().ravel(), Y.numpy().ravel()
    Uf, Vf = U.ravel(), V.ravel()
    colors = plt.cm.viridis(norm(magnitudes)).reshape(-1, 4)
    ax.quiver(Xf, Yf, Z.ravel(), Uf, Vf, W.ravel(), length=2, arrow_length_ratio=0.05, pivot="middle", color=colors, linewidth=0.7)

    mappable = plt.cm.ScalarMappable(cmap="viridis")
    mappable.set_array(magnitudes)
    fig.colorbar(mappable, ax=ax, label="||MLP2D(x)||")

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    ax.set_title("MLP2D vector field over [{minx},{maxx}]×[{miny},{maxy}] (σ_idx={sigma_idx})".format(minx=minx, maxx=maxx, miny=miny, maxy=maxy, sigma_idx=args.sigma_idx))
    ax.set_xlim(minx, maxx)
    ax.set_ylim(miny, maxy)
    ax.set_zlim(0, 0.6)

    Path(args.out).expanduser().parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    print(f"Saved gradient flow plot to {args.out}")


if __name__ == "__main__":
    main()