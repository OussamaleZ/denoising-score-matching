"""
Show the gradient flow generated by the trained MLP as a vector field.

Usage:
  python -m ncsnv2.visualization.viz_mlp_gradient_flow --config uniform_2d.yml \
      --doc <run> --ckpt-id 20000 --n 32 --out mlp_gradient_flow.png
"""

import argparse
import sys
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import torch
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

PROJECT_ROOT = Path(__file__).resolve().parents[2]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

from ncsnv2.visualization.viz_mlp_norm_2d import (
    build_model,
    load_config,
    load_state_dict,
    resolve_checkpoint,
    resolve_config_path,
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="3D vector flow for MLP outputs.")
    parser.add_argument("--config", default="uniform_2d.yml", help="Config file name or path.")
    parser.add_argument("--exp", default="/Data/ncsnv2_checkpoints/exp/exp", help="Experiment root.")
    parser.add_argument("--doc", default=None, help="Run name under logs/. Defaults to config stem.")
    parser.add_argument("--ckpt-id", type=int, default=None, help="Checkpoint suffix after checkpoint_.")
    parser.add_argument("--ckpt", default=None, help="Direct path to a checkpoint.")
    parser.add_argument("--n", type=int, default=32, help="Grid size per axis (controls number of arrows).")
    parser.add_argument("--device", default="cpu", help="Device for model and inference (cpu|cuda).")
    parser.add_argument("--out", default="figures/mlp_gradient_flow.png", help="Output image path.")
    return parser.parse_args()


def main():
    args = parse_args()

    device = torch.device(args.device)

    cfg_path = resolve_config_path(args.config)
    cfg = load_config(cfg_path)
    # ensure config carries a torch.device for functions that expect it
    cfg.device = device
    ckpt_path = resolve_checkpoint(args, cfg)
    state_dict = load_state_dict(ckpt_path)

    model = build_model(cfg).to(device)
    model.load_state_dict(state_dict, strict=False)
    model.eval()

    # use config bounds when available
    minx = getattr(cfg.data, "xmin", 0) - 1
    maxx = getattr(cfg.data, "xmax", 1) + 1
    miny = getattr(cfg.data, "ymin", 0) - 1
    maxy = getattr(cfg.data, "ymax", 1) + 1

    xs = torch.linspace(minx, maxx, args.n)
    ys = torch.linspace(miny, maxy, args.n)
    X, Y = torch.meshgrid(xs, ys, indexing="ij")
    pts = torch.stack([X.reshape(-1), Y.reshape(-1)], dim=1).to(device)

    with torch.no_grad():
        # noise level is 1
        labels = 0 * torch.ones(pts.shape[0], device=device)
        labels = labels.long()
        outputs = model(pts, labels)

    outputs = outputs if outputs.ndim > 1 else outputs[:, None]
    U = outputs[:, 0].cpu().numpy().reshape(args.n, args.n)
    V = outputs[:, 1].cpu().numpy().reshape(args.n, args.n)

    magnitudes = np.hypot(U, V)
    Z = np.zeros_like(U)
    W = np.zeros_like(U)

    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection="3d")
    norm = plt.Normalize(vmin=magnitudes.min(), vmax=magnitudes.max())
    # flatten arrays for quiver
    Xf, Yf = X.numpy().ravel(), Y.numpy().ravel()
    Uf, Vf = U.ravel(), V.ravel()
    colors = plt.cm.viridis(norm(magnitudes)).reshape(-1, 4)
    ax.quiver(Xf, Yf, Z.ravel(), Uf, Vf, W.ravel(), length=0.5, pivot="middle", color=colors, linewidth=0.7)

    mappable = plt.cm.ScalarMappable(cmap="viridis")
    mappable.set_array(magnitudes)
    fig.colorbar(mappable, ax=ax, label="||MLP(x)||")

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z")
    ax.set_title("MLP vector field over [{minx},{maxx}]Ã—[{miny},{maxy}]".format(minx=minx, maxx=maxx, miny=miny, maxy=maxy))
    ax.set_xlim(minx, maxx)
    ax.set_ylim(miny, maxy)
    ax.set_zlim(0, 1)

    Path(args.out).expanduser().parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(args.out, dpi=200)
    print(f"Saved gradient flow plot to {args.out}")


if __name__ == "__main__":
    main()
